{"meta":{"title":"Junthy's Blog","subtitle":"To Be A Better Man","description":null,"author":"Junthy","url":"https://juntao-hu.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2020-06-12T02:18:49.413Z","updated":"2020-06-12T02:18:49.413Z","comments":false,"path":"/404.html","permalink":"https://juntao-hu.github.io//404.html","excerpt":"","text":""},{"title":"about me","date":"2019-03-10T15:19:26.000Z","updated":"2019-03-10T07:24:55.137Z","comments":true,"path":"about/index.html","permalink":"https://juntao-hu.github.io/about/index.html","excerpt":"","text":"----------武汉大学一名在读计算机研究生，热爱技术，热爱生活。 ----------希望能够结识志同道合之友，这里既有酒，也有故事。"},{"title":"书单","date":"2020-06-12T02:18:49.413Z","updated":"2020-06-12T02:18:49.413Z","comments":false,"path":"books/index.html","permalink":"https://juntao-hu.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-06-12T02:18:49.429Z","updated":"2020-06-12T02:18:49.429Z","comments":false,"path":"categories/index.html","permalink":"https://juntao-hu.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-06-12T02:18:49.429Z","updated":"2020-06-12T02:18:49.429Z","comments":true,"path":"links/index.html","permalink":"https://juntao-hu.github.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2020-06-12T06:00:23.336Z","updated":"2020-06-12T02:18:49.429Z","comments":false,"path":"repository/index.html","permalink":"https://juntao-hu.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-06-12T06:00:30.377Z","updated":"2020-06-12T02:18:49.429Z","comments":false,"path":"tags/index.html","permalink":"https://juntao-hu.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"LeetCode 74. 搜索二维矩阵","slug":"LeetCode-74-search-a-2d-matrix","date":"2019-10-22T00:00:00.000Z","updated":"2019-10-22T07:40:08.127Z","comments":true,"path":"2019/10/22/LeetCode-74-search-a-2d-matrix/","link":"","permalink":"https://juntao-hu.github.io/2019/10/22/LeetCode-74-search-a-2d-matrix/","excerpt":"","text":"题目描述：编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：每行中的整数从左到右按升序排列。每行的第一个整数大于前一行的最后一个整数。示例 1:输入:matrix = [[1, 3, 5, 7],[10, 11, 16, 20],[23, 30, 34, 50]]target = 3输出: true示例 2:输入:matrix = [[1, 3, 5, 7],[10, 11, 16, 20],[23, 30, 34, 50]]target = 13输出: false来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/search-a-2d-matrix 初始代码：思路：这道题有一个性质，那就是每行按照从左到右升序排序且下一行的第一个数字要大于上一行的最后一个数字，这让我们能够想到如果将这个矩阵按照行进行首尾拼接起来最后组成一个一维数组，那么这个一维数组满足升序要求，进行二分查找很方便。那么我们所需要多做的就是，将一维数组中任一点的下标转换成矩阵中对应的坐标位置。转换位置：假设矩阵有n行。给定一个一维数组的下标mid，那么其对应的矩阵的位置为 (mid/n , mid%n)代码如下：1234567891011121314151617public boolean searchMatrix(int[][] mat, int target) &#123; //巧妙的方法，将其看成一维数组（需要做下标转换） int m= mat.length; if(m==0) return false; int n = mat[0].length; if(n==0) return false; int l=0,r=m*n-1; while(l&lt;r) &#123; int mid=(l+r+1)&gt;&gt;1; int x=mid/n; int y=mid%n; if(mat[x][y]&lt;=target) l=mid; else r=mid-1; &#125; return mat[l/n][l%n]==target?true:false; //最后判断该数组中是否存在target &#125; 优化1234int m= mat.length;if(m==0) return false;int n = mat[0].length;if(n==0) return false;替换成：1if(mat.length==0||mat[0].length==0) return false;123int x=mid/n; int y=mid%n;if(mat[x][y]&lt;=target) l=mid;替换成：12if(mat[mid/n][mid%n]&lt;=target) l=mid;虽然只是小小的优化，但是对于代码的简洁性和可读性有一定的提升","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://juntao-hu.github.io/categories/LeetCode/"}],"tags":[{"name":"二分查找","slug":"二分查找","permalink":"https://juntao-hu.github.io/tags/二分查找/"}]},{"title":"LeetCode  34. 在排序数组中查找元素的第一个和最后一个位置","slug":"LeetCode-34-find-first-and-last-position-of-element-in-sorted-array","date":"2019-10-22T00:00:00.000Z","updated":"2019-10-22T06:27:48.843Z","comments":true,"path":"2019/10/22/LeetCode-34-find-first-and-last-position-of-element-in-sorted-array/","link":"","permalink":"https://juntao-hu.github.io/2019/10/22/LeetCode-34-find-first-and-last-position-of-element-in-sorted-array/","excerpt":"","text":"题目描述：给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。你的算法时间复杂度必须是 O(log n) 级别。如果数组中不存在目标值，返回 [-1, -1]。示例 1:输入: nums = [5,7,7,8,8,10], target = 8输出: [3,4]示例 2:输入: nums = [5,7,7,8,8,10], target = 6输出: [-1,-1]来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array 初始代码：思路：利用二分找到target在数组中所在的位置，然后以该位置为初始位置分别向左和向右进行搜索，找到target在数组中的起始位置和结束位置，最后返回。缺点：因为不满足二分模板的条件，所以需要根据运行报错情况进行 mid计算公式以及 while内条件的调整代码如下：123456789101112131415161718192021222324252627282930313233public int[] searchRange(int[] nums, int target) &#123; int start = -1,end = -1; int [] a = &#123;start,end&#125;; int len = nums.length; if(len==0) return a; int l=0,r=len-1; while(l&lt;=r) &#123; int m=l+r&gt;&gt;1; if(nums[m]&lt;=target) &#123; if(nums[m]&lt;target) l=m+1; else &#123; int i=m; while((i&gt;=0)&amp;&amp;nums[i]==target) //从目标下标向左向右搜索，并更新start和end下标值 &#123; start=i; i--; &#125; i=m; while((i&lt;=r)&amp;&amp;nums[i]==target) &#123; end=i; i++; &#125; break; &#125; &#125; else r=m-1; &#125; a[0]=start;a[1]=end; return a; &#125; 同时利用两种二分模板思路：首先利用第一种二分模板去找到&gt;=target的第一个元素，若此时该元素==target，那么该元素在数组中的位置即为target的开始位置；利用第二种模板去找到&lt;=target的最后一个元素，然后记录下其下标，作为target在数组中的结束位置其实就是利用两次二分去分别找到target在数组中的起始位置和终止位置代码如下：12345678910111213141516171819202122public int[] searchRange(int[] nums, int target) &#123; //同时使用两个二分模板，分别去找到&gt;=target的第一个位置和&lt;=target的最后一个位置 if(nums.length==0) return new int[] &#123;-1,-1&#125;; int l=0,r=nums.length-1; while(l&lt;r) &#123; int mid = l+r &gt;&gt; 1; if(nums[mid]&gt;=target) r=mid; else l=mid+1; &#125; if(nums[r]!=target) return new int[] &#123;-1,-1&#125;; // 有可能数组中不存在target int start = r; //将找到的target元素在数组中的开始位置记录下来 l=start;r=nums.length-1; while(l&lt;r) &#123; int mid = l+r+1 &gt;&gt; 1; if(nums[mid]&lt;=target) l=mid; else r=mid-1; &#125; int end=r; return new int[]&#123;start,end&#125;; &#125; 注意：如果只用一个二分找到target在数组中的起始位置以后，通过顺序往后遍历的方法再找到target在数组中的终止位置，这样虽然会简单一些，但当极端情况：数组中的所有元素都是target，那么此时的时间复杂度为O(N)一点改进：up主在解题中第二次使用二分模板去寻找target在数组中的结束位置时，将开始位置l设置为0，在这里我改为了start，这样能够减少一些时间开销","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://juntao-hu.github.io/categories/LeetCode/"}],"tags":[{"name":"二分查找","slug":"二分查找","permalink":"https://juntao-hu.github.io/tags/二分查找/"}]},{"title":"二分查找算法模板","slug":"二分查找算法模板","date":"2019-10-21T00:00:00.000Z","updated":"2019-10-21T11:58:37.558Z","comments":true,"path":"2019/10/21/二分查找算法模板/","link":"","permalink":"https://juntao-hu.github.io/2019/10/21/二分查找算法模板/","excerpt":"","text":"95%的二分查找问题都可以通过两段性性质来解决两段性性质指的是：能够将问题所给的区间通过判断分成两段，假设该判断函数为check，使得两段区域中一段满足check判断，另一段不满足。 注意采用上述模板时，while中的循环条件均为 while(L&lt;R) ，最终退出循环后，模板的代码可以保证L=M，而不会出现L&gt;M的情况；因此最终返回L/M中任意一个即可当使用模板一解题时，M应为 (L+R)/2的向下取整结果，即M=(L+M)/2当使用模板二解题时，M应为 (L+R)/2的向上取整结果，即M=(L+M+1)/2 。 否则当 L=target -1， R = target 时会进入死循环 二分查找问题解决流程依照题意找到划分边界的条件，进行边界划分，并确定target的位置所在依照边界条件设计check函数编写二分代码框架依照check判断进行边界值的更新若更新边界值L=M，R=M-1 说明属于第二模板，此时更改计算M的部分为 M=(L+R+1)/2本文参考： https://www.acwing.com/blog/content/31/感谢yxc大佬的精彩讲解","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://juntao-hu.github.io/categories/LeetCode/"}],"tags":[{"name":"二分查找","slug":"二分查找","permalink":"https://juntao-hu.github.io/tags/二分查找/"}]},{"title":"LeetCode 35. 搜索插入位置","slug":"LeetCode-35-search-insert-position","date":"2019-10-21T00:00:00.000Z","updated":"2019-10-21T11:59:37.375Z","comments":true,"path":"2019/10/21/LeetCode-35-search-insert-position/","link":"","permalink":"https://juntao-hu.github.io/2019/10/21/LeetCode-35-search-insert-position/","excerpt":"","text":"题目描述：给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。你可以假设数组中无重复元素。示例 1:输入: [1,3,5,6], 5输出: 2示例 2:输入: [1,3,5,6], 2输出: 1示例 3:输入: [1,3,5,6], 7输出: 4示例 4:输入: [1,3,5,6], 0输出: 0来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/search-insert-position 初始代码：思路：第一种情况：当给定数组中包含的有该数字时，此时程序应该返回该数字在数组中的下标（也即是在数组中寻找target第一次出现的位置）；第二种情况：当给定的数组中不包含该数字时，此时程序应该返回数组中从左到右第一个大于targer的元素的所在位置作为target的插入位置特殊情况：数组中没有元素或者所有元素都小于target因此我们使用二分模板中的第一种模板，寻找数组中第一个大于或等于target的元素所在下标1234567891011public int searchInsert(int[] nums, int target) &#123; int l=0,r=nums.length-1; if(r==-1) return 0; while(l&lt;r) &#123; int mid = l+r&gt;&gt;1; if(nums[mid]&gt;=target) r=mid; else l=mid+1; &#125; return nums[r]&gt;=target?r:r+1; //判断一下target是否是数组最大的数字 &#125;这里对于特殊情况的处理是放在最后，可以在二分之前进行判断，避免不必要的二分步骤。 针对返回值的优化123456789101112public int searchInsert(int[] nums, int target) &#123; int len =nums.length; if(len==0||nums[len-1]&lt;target) return len; int l=0,r=len-1; while(l&lt;r) &#123; int mid = l+r&gt;&gt;1; if(nums[mid]&gt;=target) r=mid; else l=mid+1; &#125; return r; &#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://juntao-hu.github.io/categories/LeetCode/"}],"tags":[{"name":"二分查找","slug":"二分查找","permalink":"https://juntao-hu.github.io/tags/二分查找/"}]},{"title":"LeetCode  69. x的平方和","slug":"LeetCode-69-sqrtx","date":"2019-10-21T00:00:00.000Z","updated":"2019-10-21T11:59:38.775Z","comments":true,"path":"2019/10/21/LeetCode-69-sqrtx/","link":"","permalink":"https://juntao-hu.github.io/2019/10/21/LeetCode-69-sqrtx/","excerpt":"","text":"题目描述：实现 int sqrt(int x) 函数。计算并返回 x 的平方根，其中 x 是非负整数。由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。示例 1:输入: 4输出: 2示例 2:输入: 8输出: 2说明: 8 的平方根是 2.82842…,由于返回类型是整数，小数部分将被舍去。来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/sqrtx 初始解法（暴力遍历）：思路：因为从4开始，x的平方根要小于等于 x/2, 所以在暴力遍历的时候也不需要从1-x都遍历一遍，只需要遍历到x/2即可。时间复杂度：O(N)123456789101112public int mySqrt(int x) &#123; if(x==0) return 0; for(long i=2;i&lt;=(x/2)+1;i++) &#123; long res =i*i; if(res&lt;x) continue; if(res&gt;x) return (int) i-1; return (int) i; &#125; return 1; //说明1&lt;=x&lt;=3,则返回1&#125; 二分解法（初始）：思路：利用二分思想，初始化l=0,r=x。在不断二分迭代的过程通过m=(l+r)/2计算中间值m，依据m^2与x值的比较更新下标l和r。时间复杂度：O(N)1234567891011121314public int mySqrt(int x) &#123; if(x==1) return 1; int l=0,h=x; //划分区间，正确结果在红色区间右边界点 while(l&lt;=h) &#123; int m = (l+h)/2; long res = (long)m*m; //设置为long类型防止int溢出 if(res&lt;x) l=m; else if (res &gt; x) h = m-1; //说明此时m点在绿色区间内，更新h=m-1 else return m; &#125; return (h*h)&lt;=x?h:l; //由于此时l和h都有可能是正确结果，所以需要验证一下&#125;while中的条件为 l&lt;=h; 这可能会带来一些问题，比如当输入的x为8时, l和r的更新过程为：l=0, r=8 -&gt; l=0, r=3 -&gt; l=1, r=3 -&gt; l=2, r=3 -&gt; l=2, r=3 … 最终会陷入到死循环中，因此一开始使用测试用例没有问题，但提交时显示运行超时。最后更改如下：1234567891011121314public int mySqrt(int x) &#123; if(x==1) return 1; int l=0,h=x; //划分区间，正确结果在红色区间右边界点 while(h-l&gt;1) &#123; int m = (l+h)/2; long res = (long)m*m; //设置为long类型防止int溢出 if(res&lt;x) l=m; else if (res &gt; x) h = m-1; //说明此时m点在绿色区间内，更新h=m-1 else return m; &#125; return (h*h)&lt;=x?h:l; //由于此时l和h都有可能是正确结果，所以需要验证一下&#125;由于循环中的条件改为h-l&gt;1,因此退出循环后需要判断一下正确结果是l还是h，因为这两个都有可能。比如当输入的x是6时，l=2,h=3, l是正确结果。当输入的x为8时，l=2，h=3，此时h是正确结果。 二分解法（模板）思路：首先使用二段性将区间[0,x]分为两段，左边的元素值的平方&lt;=x，右边元素值的平方&gt;x。在计算 m值时，采用向上取整的方式，m=(l+r+1)/2, 这样当l=r-1的时候，m=(2l)/2=l。最终退出循环时，l=r即为最后的结果。时间复杂度：O(N)1234567891011public int mySqrt(int x) &#123; int l=0,r=x; while(l&lt;r) &#123; int mid = (int) ((l+(long)r+1) &gt;&gt;1);//移位运算比较快 if(mid&lt;=x/mid) //防止mid*mid 溢出 l=mid; else r=mid-1; &#125; return l;&#125;最后直接返回l而无需另加判断，所以总体上要比之前的二分代码简洁在这里有几点比较好的代码优化技巧：采用移位运算来进行除2运算，这样可以提高运算速度为了防止mid*mid溢出，这里将 mid*mid&lt;=x 改成 mid &lt;= x/mid","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://juntao-hu.github.io/categories/LeetCode/"}],"tags":[{"name":"二分查找","slug":"二分查找","permalink":"https://juntao-hu.github.io/tags/二分查找/"}]},{"title":"浦发和美团面试","slug":"浦发和美团面试总结","date":"2019-08-30T00:00:00.000Z","updated":"2020-06-12T09:30:50.347Z","comments":true,"path":"2019/08/30/浦发和美团面试总结/","link":"","permalink":"https://juntao-hu.github.io/2019/08/30/浦发和美团面试总结/","excerpt":"","text":"今天的两场面试-浦发和美团浦发：早上八点半 第一场：上机笔试 ，第二场 ： 面试美团：下午五点 视频面试 编码能力通过这几天的面试，觉得自己的编程能力真的有待提高。也许真的如左神所说，应该多花时间在刷题和总结上，这样面试时写代码才会更有底气。最近一直在思考自己该如何快速提升自己的编码能力，但想来想去，好像没有什么可以快速提升编码能力的捷径。只能靠自己不断刷题，不断总结，才能慢慢地找到那种感觉。 美团面试分享：面试官很和蔼，一开始先让我自我介绍，然后问我是使用Java是吗？我说是的，然后说问一些Java基础吧final 修饰符的含义？final修饰不可变是什么意思，能具体说清楚些吗？回答：对于值类型，final修饰指的是值不可变，对于引用类型，则是引用不可变，也就是内存地址不可变static 关键字的含义？为什么equals方法要和hashcode方法同时重写？回答：从Object类的这两个方法说起，引出第一条约定（equals相等的两个对象，hashcode一定相等），其他继承Object的类都遵守该约定。举例HashMap，如果只重写了equals方法，而不重写hashcode，可能会导致HashMap中存在两个key值相同的元素（put时，hashcode不同会被认为是两个不同的key）hashMap中的桶(buckets)是什么？以及hashMap是否安全？ConcurrentHashMap如何保证安全？答：分段锁Segment是什么？既然Segment继承自ReentrantLock，那么谈谈你对ReentrantLock的理解？回答：从ReentrantLock与Synchronized的比较进行回答AQS的原理是什么？AQS是双端队列，讲了一下具体的应用：比如 CountdownLatch 、CyclicBarrier、Semaphore等公平锁是什么？对于jvm了解吗？谈谈五大内存区域？说说了解的垃圾回收算法？知道哪些垃圾收集器？类加载的阶段有哪些？双亲委派模型知道吗？数据库了解吗？InnoDB和MyISAM的区别？B+树的特点？哪四种隔离级别？什么是聚簇索引？如果我想在索引时，先用a字段进行索引，再用b字段进行索引，该怎么做？我答的是使用联合索引，面试官说也可以。（不知道最好应该用什么？）场景设计题：如果让你设计类似于滴滴打车的软件，只考虑后端，那么你会设计哪些模块？编程题：给定一个单向链表，里面存放着数字，例如 1 2 3 2 1 ，判断该链表中存放的数字是不是回文数？比如 1 2 3 2 1 就是回文数，而 1 2 3 4 不是。给定一个数组， 4 5 6 1 2 3 ,是由1 2 3 4 5 6翻转过来的，也可以翻转成 6 1 2 3 4 5 、 3 4 5 6 1 2 ，如何快速在里面查找某个数字的下标，如果找不到，则返回-1 浦发银行-信息科技岗-武汉 --8.29 8:30am机试一共三道题，50分钟。题目都不是很难，就第一题稍微麻烦些，但对于我这个编程菜鸡时间还是不够，这里提醒大家。第一，第一题可能比后面两题都要难些，所以不要死扣第一题，即使第一题有40分。T_T否则就像我一样，第一题差一点做出来，但是时间到了，第三题压根没做。​eclipse可能没有控制台，需要自己调出来。Windows选项里面试机试完以后就是面试，需要排队等候面试问题：介绍一下自己做的项目，项目里用到了哪些技术栈主要用的编程语言是？static 关键字的作用？static 除了修饰变量、类、方法？还有呢？我没get到什么意思，就说更多的不太清楚。非静态方法可以引用静态方法吗？不可以用过的集合有哪些？ HashMap和HashSet的区别是什么？还用过哪些集合？ArrayList和LinkedList有什么区别？用过Spring吗？bean的生命周期是什么？本科是网络，那计算机网络应该很不错吧？你知道TCP的Time-Wait状态吗？==和equals的区别？Http 的请求头里有哪些字段？Sessions 在服务器端有什么作用？写一道题吧？给定一个数字，例如 129，按位依次从后往前相加，得到的结果保证为个数，直到加完，最后结果也必须为个数。 129 结果 2 , 12结果为3 。 进阶：能不用循环，使用递归实现吗？","categories":[{"name":"面试","slug":"面试","permalink":"https://juntao-hu.github.io/categories/面试/"}],"tags":[]},{"title":"HDFS读写原理","slug":"Hadoop-HDFS读写原理","date":"2019-08-25T00:00:00.000Z","updated":"2019-08-25T04:04:20.417Z","comments":true,"path":"2019/08/25/Hadoop-HDFS读写原理/","link":"","permalink":"https://juntao-hu.github.io/2019/08/25/Hadoop-HDFS读写原理/","excerpt":"","text":"Hadoop 是什么Hadoop 是一个开源的大数据框架同时也是一个分布式计算的解决方案。Hadoop = HDFS （分布式文件系统）+MapReduce（分布式计算） HDFS HDFS 概念数据块NameNodeDataNode 数据块：数据块是一个抽象的块，而不是整个文件。默认大小是64Mb，一般设置为128Mb，备份x3数据块的大小可以随着磁盘传输速率的提升而得到增加。HDFS的块比磁盘的大，主要是减少寻址时间在整个文件传输时间中的占比。比如为了让磁盘寻址时间只占到整个文件传输时间的1%，而寻址时间为10ms，磁盘的IO传输速率为100Mb/s，那么一个块的大小要大于100Mb才能达到这个要求。随着以后磁盘的传输速率越来越高，块的大小也会越来越大的。 【但是块的大小也不会很大，因为MapReduce中的map任务一次只处理一个块的数据，如果map任务过少（少于集群的节点数量），作业的运行效率也会比较慢】 对数据块进行抽象的好处：一个文件的大小可以大于集群网络中任一个磁盘的大小。因为可以对文件进行分块存储，所以在一种极端情况下，一个集群只存放了一个文件，该文件占满了集群中的所有磁盘。使用抽象块而不是整个文件作为存储单元，可以简化存储子系统的设计。首先块的大小是固定的，所以一个磁盘能够存储多少个块很容易就能够计算出来。另外也消除了对于元数据的顾虑，块只是要存储的大块数据，而文件的元数据，例如权限信息等等，并不需要与块进行一同存储，可以进行单独管理。块适合于提供备份和冗余容错的作用，通过将块进行复制副本，通常是3个，当因损坏或者机器故障而丢失的块，我们便可以从其他候选机器将副本块复制到另一台能够正常工作的机器上，保证副本的数量保持不变。HDFS集群有两类节点，以管理节点-工作节点的模式运行着，分别是NameNode和DataNode。 NameNodeNameNode ：管理文件系统的命名空间，存放着元数据 （对应文件：命名空间镜像文件）维护着文件系统树以及整棵树内所有的文件以及目录 （对应文件：编辑日志）记录着每个文件各个块所在的数据节点信息，但并不会一直保存块的位置信息，因为在重启时会根据数据节点信息重建。 联邦HDFSNameNode节点在内存中保存着文件系统中每个文件和每个数据块的引用关系，所以NameNode的内存大小会成为集群扩展的一个瓶颈。在Hadoop 2.x版本中引入了联邦HDFS，允许在集群中添加多个NameNode节点，以实现扩展。在联邦环境下，每个NameNode都维护着一个命名空间卷( 比如NameNode_1负责 /usr NameNode_2 负责 /share )，由命名空间的元数据和数据块池组成。数据块池里面存放着该命名空间下所有的数据块。命名空间卷之间不进行通信，甚至其中一个挂掉也不会影响另一个。但每个DataNode需要注册到每一个NameNode上，也需要存储着来自各个数据块池的数据块。 DataNode存储以及检索数据块向NameNode更新所存储块的列表 NameNode容错若NameNode失效，则我们无法访问到文件系统上的所有文件。因为我们不知道怎么去根据DataNode的块去重建文件。因此需要对NameNode进行容错处理。两种容错机制：对于组成文件系统元数据持久状态的文件 我们可以使NameNode在多个文件系统上对其进行保存，比如最常用的就是在将持久状态写入本地磁盘的同时也将其写入到远程挂载的NFS网络文件系统中。运行一个辅助NameNode节点 （Secondary NameNode）该节点却不能被用作NameNode，它的主要作用是定期合并编辑日志文件和命名空间镜像文件，防止其过大。它在合并后会生成命名空间镜像文件的副本，当NameNode失效时会启用。但是辅助NameNode节点保存的信息总是会滞后于NameNode节点，所以如果想要实现容错机制，可以在主NameNode节点失效后，将保存在NFS的文件系统元数据复制到Secondary NamoNode上来，将其作为新的主NameNode运行。HA高可用 HDFS 优点适合大文件存储，支持TB、PB级文件的存储可以构建在廉价的机器上，并能够提供容错机制和恢复机制支持流式数据访问，一次写入，多次读取更高效 HDFS 缺点不适合大量小文件存储不适合并发写入，也不支持文件随机修改不支持随机读等低延迟的访问方式 HDFS 读写流程 HDFS 读流程HDFS读流程图(图片来源-慕课网)假设现在有三个DataNode节点，分别存放着数据Data数据块1、数据块2、数据块1、2，则如果此时客户端想要请求Data数据，流程如下：Client向NameNode发出请求，请求Data文件。NameNode通过其所维护的相关的数据块的信息，会把该Data文件的所有block的所有的DataNode信息返回给Client。然后Client随即从距离(按照带宽进行计算出来的距离) 最近且保存着文件第一个块的DataNode节点上读取数据在读取完第一个块的数据以后，便会寻找下一个块的最佳DataNode，并从其上读取数据，直到将所有的Data文件块数据读取完毕如果在读取的过程中，遇到问题（比如读取的DataNode节点挂掉了），则客户端会再次去寻找存有该块信息副本的DataNode节点，并从其上读取出块数据。如下图所示：然而上述的流程有些地方不够完善。客户端是怎么去读取块的数据的？读过程对于客户端而言是否是透明的？依据距离去寻找最优的DataNode节点，这个距离是如何计算的？详细的读流程图如下所示： 客户端如何读取DataNode上所存的块数据？步骤一：客户端通过FileSyste对象的open()方法去打开希望读取的文件；步骤二：此时，DistributedFileSystem会通过RPC去调用NameNode，然后NameNode会返回存有该文件所有block的所有的DataNode信息 （对于每一个块，NameNode会返回存有该块副本的DataNode信息，并按照距离对DataNode进行排序）；步骤三：然后，DistributedFileSystem类会返回一个FSDataInputStream对象给客户端去读取数据该FSDataInputStream类会封装DFSInputStream对象，该对象管理着datanode和namenode的I/O步骤四：客户端对这个数据流调用read()方法去读取块数据：DFSInputStream里存放着文件前几个块的副本的所有DataNode地址，于是会去连接距离最近的DataNode步骤五：Client通过对数据流反复调用read()方法，在DFSInputStream读取完第一个块的数据以后，会关闭与该DataNode的连接，转而去连接下一个距离最近且存着第二个块数据的DataNode节点，继续读取数据。整个过程对于Client而言是完全透明的，在客户端而言，它一直在读取一个连续的数据流步骤六：Client在读取了文件前几个块的数据以后，根据需要，Client可能会询问NameNode节点检索下一批DataNode数据块的位置，然后继续通过DFSInputStream去读取数据。客户端一旦完成了数据读取，便会对FSDataInputStream调用close()方法。 读取流程的细节：在读取过程中，如果某一个DataNode发生故障，DFSInputStream会尝试连接另外一个最临近的DataNode，并记下该故障DataNode，保证后面不会再去该节点读取数据。DFSInputStream会通过校验和去检查读取的文件的正确性。这种读取流程，让NameNode的工作量大大减少，只需要响应客户端的块位置请求即可，无需响应数据请求，所以可以支持高扩展。距离是按照带宽来进行计算的，一般来说可以依据场景，对带宽进行递减：1.同一节点的不同进程2.同一机架的不同节点3.同一数据中心的不同机架上的节点4.不同数据中心的节点 HDFS写流程HDFS写流程图（图片来源-慕课网）首先，客户端会向NameNode请求写入文件NameNode通过查询自己维护的节点信息，向客户端返回还有空间可以存放数据的DataNode节点信息客户端将data文件进行分块，然后将块内容以及NameNode发送给客户端的信息一起发送给DataNode-1DataNode-1收到以后，会在管线中进行块数据的备份复制，使得达到块数据的最小复本数当DataNode-1-2-3都存储完数据块以后，将会反馈给NameNode存储完成数据块-1信息，NameNode更新一下元数据信息，接着NameNode再将该信息返回给客户端客户端再次开始存储数据块-2然而上述的流程还不够清晰，有很多细节值得去深入了解一下。比如：客户端是如何将块文件写入到DataNode中的，是以块为单位直接传输吗？DataNode如何实现将数据备份到其他DataNode节点上的呢？如果在写入块数据的过程中，发生了错误，HDFS会怎么处理呢？来自《Hadoop权威指南》的HDFS写文件流程图： 客户端如何将文件写入到DataNode？create：客户端通过DistributedFileSystem对象调用create()方法来创建一个新文件DistributedFileSystem的create()方法会返回一个FSDataOutputStream对象FSDataOutputStream封装了一个DFSOutputStream对象，在其构造函数中会使用RPC远程调用NameNode的create()方法来创建一个文件NameNode会先对文件创建操作进行检查（比如该客户端有没有权限创建文件，该文件名是否已经存在？），若检查没问题，NameNode则为创建新文件做一条记录，否则创建失败，并向客户端返回IOException异常write packet 和 ack packet：客户端写入数据块时，DFSOutputStream将其分成一个一个的包（packet），将packet放到pipeline（管线）里进行写入。写入时，会使用两个队列，一个是“数据队列”用于存放要写入packet；一个则是“确认队列“，用于接收DataNode发来的确认Ack。写入过程：（DataStreamer负责处理）一般会使用FSDataOutputStream的write方法FSDataOutputStream的write方法会调用DFSOutputStream的write方法，而DFSOutputStream继承自FSOutputSummer，所以实际上是调用FSOutputSummer的write方法首先将package 1写入DataNode 1然后由DataNode 1负责将package 1写入DataNode 2，同时客户端可以将pacage 2写入DataNode 1然后DataNode 2负责将package 1写入DataNode 3, 同时客户端可以讲package 3写入DataNode 1，DataNode 1将package 2写入DataNode 2就这样将一个个package排着队的传递下去，直到所有的数据全部写入并复制完毕确认过程：DataStreamer线程负责把准备好的数据packet，顺序写入到DataNode，未确认写入成功的packet则移动到ackQueue，等待确认。DataStreamer线程传输数据到DataNode时，要向namenode申请数据块，在NameNode分配了DataNode和block以后，createBlockOutputStream开始写入数据。只有对于一个数据包（packet）收到管道内的所有DataNode的ack之后，才能将该数据包从确认队列中删除。 当写入时有DataNode发生故障，导致数据无法正常写入，该怎么处理？？DataStreamer会启动ResponseProcessor线程，它负责接收datanode的ack首先将管线关闭将确认队列的数据包添加回数据队列的前端将发生故障的DataNode从管线中移除在另一个正常的DataNode节点对当前的数据块做一个标记，并将标识发给NameNode，使损坏的DataNode恢复正常后能够删除已存储的部分数据块通过RPC调用DataNode的recoverBlock方法来恢复数据块以剩下的DataNode节点建立新的管线，继续写入数据（NameNode注意到块复本数量不足时，会重新添加一个DataNode进行副本数据保存） HDFS如何选择副本的存储位置？副本存放位置的选定需要同时对可靠性、写入带宽和读取带宽同时均衡考量进行选取默认布局：第一个副本一般放在客户端，如果客户端在数据中心之外，则会随机在数据中心选择一个节点第二个副本，选择和第一个在不同的机架的一个节点第三个副本则选择和第二个副本在一个机架上，但是是不同的节点后面的副本会随机选择，不过系统会尽量避免一个机架上会存放过多的副本 参考资料慕课网-Hadoop基础及演练 : https://www.imooc.com/learn/928HDFS-dfsclient写文件过程源码分析:https://www.cnblogs.com/ggjucheng/archive/2013/02/19/2917020.html《Hadoop权威指南》","categories":[{"name":"Hadoop","slug":"Hadoop","permalink":"https://juntao-hu.github.io/categories/Hadoop/"}],"tags":[{"name":"HDFS","slug":"HDFS","permalink":"https://juntao-hu.github.io/tags/HDFS/"}]},{"title":"基本排序算法（Java）","slug":"基本排序算法-Java","date":"2019-04-13T00:00:00.000Z","updated":"2019-04-13T13:52:35.405Z","comments":true,"path":"2019/04/13/基本排序算法-Java/","link":"","permalink":"https://juntao-hu.github.io/2019/04/13/基本排序算法-Java/","excerpt":"","text":"基本排序算法 (Java)经过几次笔试，发现自己的Java基础有些薄弱，基本的排序算法掌握的还不够熟练，需要多加学习总结。 选择排序思想: 给定一个整数数组,例 int[] a ={38,65,97,76,13,27,49}，首先进行第一轮比较：遍历整个数组，选出最小的数字，以及该数字所在数组的下标，然后将该元素与数组的第一个元素进行交换。第二轮比较：比较范围为从数组的第二个元素开始，选择出最小的元素，并与数组的第二个元素交换位置… 多轮比较后直到待选择元素只剩下一个。此时该数组就是升序了。时间复杂度：最好、最坏、平均都是O(n^2)空间复杂度:O(1)稳定性：不稳定的排序算法：例[2(1),5,3,2(2),1] 经过选择排序后变成[1,2(2),2(1),3,5]当n较小时，排序效果较好代码实现如下:12345678910111213141516171819202122232425public static int[] selectSort(int[] a) &#123; if(a.length==1) return a; if(a.length==0) return null; int i,j,index; //index记录最小值元素所在下标 int min; for(i=0;i&lt;a.length-1;i++) &#123; index=i; min=a[i]; for(j=i+1;j&lt;a.length;j++) &#123; if(a[j]&lt;min) &#123; min=a[j]; index=j; &#125; &#125; a[index]=a[i]; a[i]=min; &#125; return a; &#125; 直接插入排序思想：对于给定的一个整数数组，例如a ={38,65,97,76,13,27,49}，假定第一个元素自成一个有序序列，其他的元素为无序序列。则按顺序从无序序列中挑出一个元素，插入到有序序列的末尾，然后对该有序序列重新排序，生成一个新的有序序列，然后再依次这样从无序序列中挑出元素，构建新的有序序列，直到最后一个元素插入到有序序列中并重新构建出最终的有序序列。时间复杂度: 最好：O(n)，最坏：O(n2)，平均：O(n2)空间复杂度：O(1)稳定性：稳定当大部分有序时，排序效果较好代码实现如下:12345678910111213141516171819202122232425public static int[] insertSort(int[] a) &#123; if(a.length==1) return a; if(a.length==0) return null; int i,j,tmp; for(i=1;i&lt;a.length;i++) &#123; tmp=a[i];//选出的待插入元素 j=i; if(a[j-1]&gt;tmp) &#123; //当在有序序列中出现比待插入元素大的元素时，将该元素后移一位 //j代表待插入元素在有序序列中插入的位置下标 while(j&gt;=1&amp;&amp;a[j-1]&gt;tmp) &#123; a[j]=a[j-1]; j--; &#125; &#125; a[j]=tmp; &#125; return a; &#125; 冒泡排序思想：在冒泡排序中，对于给定的整形数组a={38,65,97,76,13,27,49},第一轮排序比较：从第一个元素开始，与其相邻的元素进行比较，若右边元素比左边元素大，则交换位置；然后继续从第二个元素开始进行比较，直到比较到倒数第二个元素。此时，数组中最后一个元素是最大的元素，然后再进行第二轮比较，比较范围是从当前数组第一个元素到倒数第三个元素，即找出第二大的元素，放到末尾…经过(a.length-1) 这里是6次比较后，得到了最终的升序排序结果。时间复杂度：最好：O(n)，最坏和平均都是：O(n^2)空间复杂度：O(1)稳定性：稳定当n较小时，排序效果较好代码如下：12345678910111213141516171819public static int[] bubbleSort(int[] a) &#123; int len=a.length,tmp; if(len==0) return null; if(len==1) return a; for(int i=0;i&lt;len;i++) //经过n-1次比较 for(int j=0;j&lt;len-i-1;j++) //每次比较的范围是 a[0,n-i-1) &#123; if(a[j]&gt;a[j+1]) &#123; tmp=a[j]; a[j]=a[j+1]; a[j+1]=tmp; &#125; &#125; return a; &#125; 归并排序思想：归并排序，归是递归，并是合并。首先对给定的数组进行折半，直到折半成最小的子数组，比如只包含一个元素。然后再依次进行两两合并，合并时按照顺序进行排序，得到有序的子数组，再对这些子数组进行两两合并，直到生成最终的一个数组，即是有序的数组了。比如数组[2,6,1,0]先对其进行不断地折半，生成[2],[6],[1],[0]四个子数组，然后再对其进行两两合并，生成[2,6]，[0,1]两个数组，然后再对这两个有序数组进行两两合并，最终生成[0,1,2,6]这个最终的有序数组。时间复杂度：最好，最坏，平均都是O(nlog(n))空间复杂度：O(n)稳定性：稳定当n数目较大时较好代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public static int[] num = &#123;38,65,97,76,13,27,49&#125;; public static void MergeSort(int[] a,int[] array_tmp,int p,int q,int r) &#123; int i,j,k,l_end,r_end; l_end=q+1; r_end=r+1; for(i=p,k=p;i&lt;l_end;i++,k++) array_tmp[i]=a[k]; for(j=q+1,k=q+1;j&lt;r_end;j++,k++) array_tmp[j]=a[k]; for(k=p,i=p,j=q+1;i&lt;l_end&amp;&amp;j&lt;r_end;k++) //执行完一次循环以后，k会自动加一，然后执行条件判断 &#123; if(array_tmp[i]&lt;=array_tmp[j]) //这样便是稳定的排序了 &#123; a[k]=array_tmp[i]; i++; &#125; else &#123; a[k]=array_tmp[j]; j++; &#125; &#125; if(i&lt;l_end) &#123; for(;i&lt;q+1;i++,k++) a[k]=array_tmp[i]; &#125; if(j&lt;r_end) &#123; for(;j&lt;r+1;j++,k++) a[k]=array_tmp[j]; &#125; &#125; public static void Merge(int[] a,int[] array_tmp,int p,int r) &#123; if(p&lt;r) &#123; int q=(p+r)/2; Merge(a,array_tmp,p,q); Merge(a,array_tmp,q+1,r); MergeSort(a,array_tmp,p,q,r); &#125; &#125; public static void main(String[] args) &#123; int[] array_tmp = new int[num.length];//使用的辅助空间大小为n Merge(num,array_tmp,0,num.length-1); for(int i:num) System.out.print(i+\" \"); &#125; 快速排序思想：快速排序采用分而治之的思想，对于一个给定的数组，还是以a{38,65,97,76,13,27,49}为例，先是随机选取其中的一个数（可以是选择数组中的第一个元素，也可以是数组中的最后一个元素，还可以从左、右、中间随机数中选择大小取中的值）作为一个基准值，然后将该数组分成左右两个部分，左边的数字都比基准数字小，右边的数字都比基准数字大，此时该基准数字的位置就是其在排序后数组中的最终位置。然后对左右两边的子无序数组，再进行上述的排序过程，通过不断地拆分，直到所有元素都找到了其真正所属的位置下标，排序结束。时间复杂度：最坏：O(n^2) [ 当每次进行选取的基准关键字都是最小的或者最大的，使得区间划分的结果一边为空，此时比较次数是1+2+3+…+n-1=n(n-1)/2即n^2 ]，最好和平均：O(nlog(n)) 快速排序的平均性能是最好的空间复杂度：O(log(n)) [ 快速排序需要一个栈空间来实现递归，当情况最好时，栈空间的大小为 log(n)+1,当情况最坏时，栈空间大小为n，平均空间复杂度为 O(log(n)) ]稳定性：不稳定当n较大时，排序效果较好代码如下：1234567891011121314151617181920212223public static void QuickSort(int[] a,int start,int end) &#123; if(start&gt;=end) //一定要记得加上递归结束条件，否则会造成 StackOverflowError错误 return; int i,j,index; index=a[start]; i=start; j=end; while(i&lt;j) &#123; while(i&lt;j&amp;&amp;a[j]&gt;=index) j--; if(i&lt;j) a[i++]=a[j]; while(i&lt;j&amp;&amp;a[i]&lt;index) i++; if(i&lt;j) a[j--]=a[i]; &#125; a[i]=index; QuickSort(a,start,i-1); QuickSort(a,i+1,end); &#125; 希尔排序思想：希尔排序也称为“缩小增量排序”，其基本思想是通过选定一个 步长序列，比如T{t1,t2,…ti…tn}。步长序列一般是逐渐缩小的，即前面的步长要比后面的步长要大。当选定步长序列以后，对每一个步长ti，根据步长将给定待排序数组分成多个子序列。比如待排序数组a={12,11,10,9,8,7,6,5,4,3,2,1},步长此时为ti=3。则根据步长将数组a分成{12,9,6,3}、{11,8,5,2}、{10,7,4,1}这三个子序列。然后对这三个子序列进行直接插入排序，得到排序结果后再依照步长序列中后面的步长再进行直接插入排序。最后的步长tn一般取为1，也就是最后一次是将所有元素看成一组进行直接插入排序，此时一般来说整个数组基本有序，所需要的交换次数很少。时间复杂度：最好是：O(n) 最坏：O(n^s) (1&lt;s&lt;2) 平均：O(nlog(n))空间复杂度：O(1)稳定性：不稳定希尔排序属于插入排序的一种代码如下：1234567891011121314151617181920public static void ShellSort(int[] a) &#123; int len=a.length; int i,j,tmp; int h;//h为步长 for(h=len/2;h&gt;0;h=h/2) &#123; for(i=h;i&lt;len;i++) &#123; tmp=a[i]; for(j=i-h;j&gt;=0;j-=h) &#123; if(tmp&lt;a[j]) a[j+h]=a[j]; else break; &#125; a[j+h]=tmp; &#125; &#125; &#125; 堆排序思想：对于给定的数组序列，例如a={38,65,97,76,13,27,49}，初始时先将其看作一棵顺序存储的二叉树，即a[0]为根节点，a[1]、a[2]为其左右子节点。然后将该树调整成为一个小顶堆，然后将堆中的最后一个元素a[n-1]与堆顶元素（即二叉树的根节点，也是最小的元素）进行交换。接着将前n-1个元素重新调整成一个小顶堆，再将堆顶元素与该堆中的最后一个元素a[n-2]进行交换，得到次最小元素，重复上述过程，直到调整的堆中只剩下一个元素为止，该元素即为数组中的最大元素。此时该数组就变成了降序数组了。时间复杂度：最坏、最好、平均都是O(nlog(n))空间复杂度：O(1)稳定性：不稳定当n较大时，排序效果较好代码如下：12345678910111213141516171819202122232425262728293031323334353637public static void sift(int[] a,int low,int high)&#123; int i=low,j=2*i+1; int tmp; while(j&lt;=high) //判断a[i]是不是父节点，若a[i]是父节点，则2*i小于high &#123; if((j&lt;high)&amp;&amp;(a[j]&gt;a[j+1])) //如果存在右孩子，且左孩子小于右孩子，则指向右孩子 j++; if(a[i]&gt;a[j]) &#123; tmp=a[i]; a[i]=a[j]; a[j]=tmp; i=j; j=2*i+1; &#125; else //别忘记 break 终止，否则会一直循环下去 break; &#125;&#125; public static void main(String[] args) &#123; int[] a = &#123;2,5,8,6,1,4,7&#125;; int n = a.length-1; int i,tmp; //构建初始堆 for(i=n/2-1;i&gt;=0;i--) sift(a,i,n); for(i=n;i&gt;=1;i--) &#123; tmp=a[i]; a[i]=a[0]; a[0]=tmp; sift(a,0,i-1); &#125; for(int m:a) System.out.println(m); //此时数组a为降序有序 &#125;文章内容主要参考《Java面试宝典》数据结构与算法章节，感谢作者的精彩讲解。","categories":[{"name":"Java","slug":"Java","permalink":"https://juntao-hu.github.io/categories/Java/"}],"tags":[{"name":"基本排序算法","slug":"基本排序算法","permalink":"https://juntao-hu.github.io/tags/基本排序算法/"}]},{"title":"阿里面试总结","slug":"阿里电话面试","date":"2019-03-21T00:00:00.000Z","updated":"2019-03-21T11:41:39.344Z","comments":true,"path":"2019/03/21/阿里电话面试/","link":"","permalink":"https://juntao-hu.github.io/2019/03/21/阿里电话面试/","excerpt":"","text":"阿里实习电话面试总结这次面试主要问的是项目中Hadoop相关的知识，包括MR程序等等。后来还问了算法设计问题：在单机环境下，从数千万条数据中选取出最大的前k个数，如何编写MR程序？最后问了Java的相关知识，包括线程的wait和sleep方法的区别？发现自己基础太薄弱了，主要是java方面基础太薄弱。下一步计划：啃透java面试宝典、Hadoop权威指南，把项目中的数据架构弄懂，Spark算子部分以及算法设计部分弄懂、剑指offer弄懂、java虚拟机过一遍、Hive语法然后是Spqrk高级特性、MapReduce设计模式、二刷剑指offer、二刷java虚拟机、java面试宝典","categories":[{"name":"面试","slug":"面试","permalink":"https://juntao-hu.github.io/categories/面试/"}],"tags":[]},{"title":"《Spark大数据处理》- Spark原理","slug":"《Spark大数据处理》- Spark原理","date":"2019-03-10T00:00:00.000Z","updated":"2019-03-10T06:55:28.568Z","comments":true,"path":"2019/03/10/《Spark大数据处理》- Spark原理/","link":"","permalink":"https://juntao-hu.github.io/2019/03/10/《Spark大数据处理》- Spark原理/","excerpt":"","text":"","categories":[{"name":"Spark","slug":"Spark","permalink":"https://juntao-hu.github.io/categories/Spark/"}],"tags":[{"name":"Spark原理","slug":"Spark原理","permalink":"https://juntao-hu.github.io/tags/Spark原理/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://juntao-hu.github.io/tags/读书笔记/"}]},{"title":"Java链表基本操作和Java.util.ArrayList","slug":"Java链表基本操作","date":"2019-02-26T00:00:00.000Z","updated":"2019-03-10T06:55:25.641Z","comments":true,"path":"2019/02/26/Java链表基本操作/","link":"","permalink":"https://juntao-hu.github.io/2019/02/26/Java链表基本操作/","excerpt":"","text":"今天做了一道《剑指offer》上的一道编程题“从尾到头打印链表”，具体要求如下：输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。一开始我想的是通过两次遍历链表，第一次遍历得到链表元素的个数count。然后定义一个ArrayList 变量，由于ArrayList是动态数组，不能在未初始化的情况下对任意位置进行插入指定的值。所以只能先对其进行初始化，将count个ArrayList元素赋值为初始值0。随后第二次遍历链表，将遍历得到的值，按照倒序计算出位置i，将ArrayList对应位置i的值设定为该遍历值。后来发现别人大多都是用递归来做的，因为递归的原理是堆栈，先进后出，所以最后实现的堆栈输出顺序正好是从尾到头的顺序。时间复杂度比我的方法要优。通过今天的做题，发现自己对于Java对单链表的操作以及java.ArrayList()的一些特性不太熟悉，所以想把今天收集到的资料记录一下，让自己能够记得清楚一些。 Java对于单链表的基本操作：链表是一种常见的数据结构，链表不同于数组，其存储的位置可能不是连续的。所以当我们想要在链表中查找指定位置的结点时，只能去对链表进行遍历。而数组则直接能够通过位置找到相应的元素结点，时间复杂度为O（1）。单链表的结构如下图所示：下面定义Java链表的实体类Node：123456789package com.algorithm.link;public class Node &#123;Node next = null;int val; //节点中的值public Node(int val) //Node的构造函数 &#123; this.val = val; &#125; &#125;Java中对单链表的常见操作：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.algorithm.link;public class MyLinkedList&#123; Node head = null; //定义头结点指针 /*-------------链表添加结点------------*/ public void addNode(int val) &#123; Node NewNode = new Node(val);//创建要添加的结点 if(head==null) //当链表为空时 &#123; head=NewNode; return; &#125; else &#123; //当链表不为空时，则先找到链表的尾结点，然后插入待插入的结点 Node tmp = head; while(tmp.next!=null) &#123; tmp=tmp.next; &#125; tmp.next=NewNode;//此时tmp为链表的尾结点 &#125; &#125; /*------------链表删除结点----------*/ public boolean deleteNode(int index) &#123; if(index==1)//说明删除的是头节点 &#123; head=head.next; return true; &#125; int i=2; //因为链表不止两个结点，所以定义一个前结点，一个当前结点，分别指向目标结点的前结点和目标结点 Node preNode = head; Node curNode = head.next; while(curNode!=null) &#123; if(index==i)//找到要删除的结点了,此时curNode指向该结点 &#123; preNode.next=curNode.next;//删除结点 return true; &#125; //preNode和curNode结点分别向后移动一位 preNode=preNode.next; curNode=curNode.next; i++; &#125; return true;//按照前面的一定能够找到待删除的结点，这句语句不会执行，只是为了程序能够通过编译。 &#125;&#125; Java.util.ArrayList:ArrayList是一种动态数组，可以根据元素增加的情况动态的重新分配空间，是Array的复杂版本。ArrayList相对于Array有以下几个优点：可以动态的增加或减少元素实现了ICollection和IList接口可以灵活的设置数组的大小 首先构建一个ArrayList，其提供了三种构造方法：public ArrayList();默认的构造器，将会以默认（16）的大小来初始化内部的数组public ArrayList(ICollection);用一个ICollection对象来构造，并将该集合的元素添加到ArrayListpublic ArrayList(int);用指定的大小来初始化内部的数组在构造ArrayList时，可以指定ArrayList的类型，例:ArrayLista = new ArrayList();或ArrayListb = new ArrayList();但指定的类型必须为构造器类型(component type) 对ArrayList的基本操作：add() 增加元素remove(Object o) 遍历ArrayList，删除遇到的第一个指定的元素o例： a.remove(new Integer(8)) //删除第一个元素值为8的元素remove(index i) 根据下标来删除ArrayList中指定位置的元素clear() 清除ArrayList中的所有元素contains(Object o) 判断ArrayList中是否存在指定值的元素 将ArrayList 转换为Array数组：ArrayList提供 publicT[] toArray(T[] a)方法能够将ArrayList类型数组转换为普通Array数组，例如我们定义了一个Integer 类型的ArrayList数组: ArrayLista = new ArrayList() 并在其上通过循环，add了10个元素。此时，我们若想将其转换成为数组可以这样去转换：1Integer[] value=(Integer[])a.toArray(new Integer[a.size()]);上述返回的数组的长度大小正好为a数组的大小，我们也可以指定new Integer[]里面的数字，当该长度容纳不下待转换的ArrayList元素个数时，该方法会重新依据ArrayList的大小重新分配一个数组，将ArrayList a 中的元素复制到里面并返回。当指定的数目大于a中的元素个数时，也就是数组的空间有剩余。此时，toArray()方法会将剩余的数组部分的元素值都置为 null。 将数组转换为ArrayList：12String数组 array;List&lt;String&gt; list=Arrays.asList(array); //将String数组array转化成List但上述的转化方法返回的list无法对其进行修改和增加元素，仿佛是静态固定的。[解释] 所以还可以通过以下的方法去将数组转换成ArrayList:1ArrayList&lt;String&gt; c = new ArrayList&lt;String&gt;(Arrays.asList(array));此时返回的ArrayList数组可以正常地对其进行操作。 关于数组扩容对ArrayList效率的影响问题：当我们以默认不带指定大小的构造器去构造一个ArrayList时，默认会将其大小初始化分配为16。在我们使用增加元素的方法之前，例如使用add（）、addAll（）等，都会首先检查内部数组的大小是否够用，如果不够用，则会以当前容量的两倍来重新构建一个数组，并将旧数组的元素copy到新数组中，并丢弃掉旧数组。这种在临界点进行扩容的操作，会比较影响效率。比如，一个可能有200个元素的数据动态添加到一个以默认16个元素大小创建的ArrayList中，将会经过： 16*2*2*2*2 = 256 四次的扩容才会满足最终的要求，那么如果一开始就以： ArrayList List = new ArrayList( 210 ); 的方式创建ArrayList，不仅会减少4次数组创建和Copy的操作，还会减少内存使用。另外一种可能发生的情况是，比如我们定义了一个ArrayList数组，且其大小为30，但我们却有31个元素要添加进去，该ArrayList数组则会经过一个扩容容量变为60，这样最后便会有29个元素的存储空间是浪费掉的。此时，我们可以通过 trimToSize 方法去让当前数组的大小变为实际元素个数的大小，还可以提前大致预测一下数组的大小，然后在数组创建之时就指定好大小，这样能够避免去浪费更多的空间。 java.util.Arrays()、java.util.ArrayList()、java数组之间的关系:Arrays()实现了对数组的一系列操作方法，而ArrayList是动态数组，其大小可以动态变化。 参考文章java实现单链表操作 ：https://www.cnblogs.com/bjh1117/p/8335108.htmljava.util.ArrayList() : https://www.cnblogs.com/qingchunshiguang/p/6103731.html","categories":[{"name":"Java","slug":"Java","permalink":"https://juntao-hu.github.io/categories/Java/"}],"tags":[{"name":"Java链表","slug":"Java链表","permalink":"https://juntao-hu.github.io/tags/Java链表/"},{"name":"ArrayList","slug":"ArrayList","permalink":"https://juntao-hu.github.io/tags/ArrayList/"},{"name":"剑指offer","slug":"剑指offer","permalink":"https://juntao-hu.github.io/tags/剑指offer/"}]},{"title":"Java.util.Arrays 常用方法","slug":"Java.util.Arrays的常用方法","date":"2019-02-13T00:00:00.000Z","updated":"2019-03-10T06:55:27.156Z","comments":true,"path":"2019/02/13/Java.util.Arrays的常用方法/","link":"","permalink":"https://juntao-hu.github.io/2019/02/13/Java.util.Arrays的常用方法/","excerpt":"","text":"Array 简介java.util.Arrays 类能够方便地对数组进行操作，它所提供的所有方法都是静态的。其中最常用的有以下几个方法：binarySearch()方法实现在数组中进行查找fill()方法实现对数组进行值填充equals()方法实现数组之间的比较sort()方法实现对数组进行升序排序 1. binarySearch()方法：Arrays.binarySearch()方法能够对byte、char、float、int、long、short甚至是特定的object型数组进行二叉树查找。前提: 要查找的数组已经按照升序排好序了，这样才能构造出相应的二叉树用于查找。基本语法：12int[] a = &#123;1,2,3,4,5&#125; //已经排好序Arrays.binarySearch(a,5) //Arrays.binarySearch(int[] a,int key)Result: 4此外，通过设置 fromIndex 和 toIndex ，binarySearch()还能够指定在数组中查找的范围。基本语法：1Arrays.binarySearch(int[] a,int fromIndex,int toIndex,int key)//在数组a中从下标fromIndex到toIndex开始查找key所在的位置下标当数组中包含key值时，查找成功并返回key值所在的数组下标。但当数组中不包含key值时，查找失败，此时返回的值是在所构建的查找二叉树中key值所在的位置取负值。例如对数组 a=[1,2,9,10] 所构建的查找二叉树如下所示：对于不在数组中的待查找元素，则根据其在查找二叉树中的位置取负数得到方法的返回值。例：查找12，则返回的值为-5。 2. fill()方法：通过Arrays.fill()方法可以对数组进行赋值，通常用在数组的初始化。同样的，fill方法可以支持所有的基本数据类型以及自定义的object类型数组。语法如下：12Arrays.fill(int[] a,int val) //用val值来填充数组aArrays.fill(int[] a,int fromIndex,int toIndex,int val) //用val值来填充数组a中所指定的范围 3. sort()方法：通过Arrays.sort()方法可以对数组进行升序排序。语法如下：12int[] a =&#123;1,2,3,5&#125;;Arrays.sort(a); //对数组a进行升序排序如果要实现对数组进行降序排序，可以重写comparator比较器：12345678910111213141516171819202122public static void main(String[] args) &#123; /*注意，要想改变默认的排列顺序，不能使用基本类型（int,double, char） 而要使用它们对应的类*/ Integer[] a = &#123;9, 8, 7, 2, 3, 4, 1, 0, 6, 5&#125;; //定义一个自定义类MyComparator的对象 Comparator cmp = new MyComparator(); Arrays.sort(a,cmp); for(int arr:a) &#123; System.out.print(arr + \" \"); &#125; &#125; &#125; //实现Comparator接口 class MyComparator implements Comparator&lt;Integer&gt;&#123; @Override public int compare(Integer o1, Integer o2) &#123; /*如果o1小于o2，我们就返回正值，如果o1大于o2我们就返回负值， 这样颠倒一下，就可以实现降序排序了,反之即可自定义升序排序了*/ return o2-o1; &#125; &#125; 4. equals()方法：通过Arrays.equals()方法能够对给定的两类数组进行比对，最终会返回一个布尔类型的值。当两个数组完全相等时，返回True，否则是False。1Ayyars.equals(int[] a, int aFromIndex, int aToIndex, int[] b, int bFromIndex, int bToIndex)在比较两个数组的过程，可以指定两个数组的比较范围，并返回比较结果。 5. mismatch()1Arrays.mismatch(int[] a,int[] b)返回数组a和数组b中第一个出现不匹配的元素的下标，若都匹配，则返回-1。 6. copy()123int[] a =&#123;1,2,3,4,5&#125;;int[] b =new int[8];b=Arrays.copyof(a,LengthOfCopy);//将a数组中截取前length长度元素复制到数组b中当LengthOfCopy超出a的下标范围或者b的下标范围则一律补0，也就是说数组b的长度是可变的也能够通过Arrays.copyOfRange(int[] original, int from, int to)来指定复制的范围。 7. hashCode()通过Arrays.hashCode()方法，能够返回由数组内容生成的Hash值。","categories":[{"name":"Java","slug":"Java","permalink":"https://juntao-hu.github.io/categories/Java/"}],"tags":[{"name":"Arrays","slug":"Arrays","permalink":"https://juntao-hu.github.io/tags/Arrays/"}]}],"categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://juntao-hu.github.io/categories/LeetCode/"},{"name":"面试","slug":"面试","permalink":"https://juntao-hu.github.io/categories/面试/"},{"name":"Hadoop","slug":"Hadoop","permalink":"https://juntao-hu.github.io/categories/Hadoop/"},{"name":"Java","slug":"Java","permalink":"https://juntao-hu.github.io/categories/Java/"},{"name":"Spark","slug":"Spark","permalink":"https://juntao-hu.github.io/categories/Spark/"}],"tags":[{"name":"二分查找","slug":"二分查找","permalink":"https://juntao-hu.github.io/tags/二分查找/"},{"name":"HDFS","slug":"HDFS","permalink":"https://juntao-hu.github.io/tags/HDFS/"},{"name":"基本排序算法","slug":"基本排序算法","permalink":"https://juntao-hu.github.io/tags/基本排序算法/"},{"name":"Spark原理","slug":"Spark原理","permalink":"https://juntao-hu.github.io/tags/Spark原理/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://juntao-hu.github.io/tags/读书笔记/"},{"name":"Java链表","slug":"Java链表","permalink":"https://juntao-hu.github.io/tags/Java链表/"},{"name":"ArrayList","slug":"ArrayList","permalink":"https://juntao-hu.github.io/tags/ArrayList/"},{"name":"剑指offer","slug":"剑指offer","permalink":"https://juntao-hu.github.io/tags/剑指offer/"},{"name":"Arrays","slug":"Arrays","permalink":"https://juntao-hu.github.io/tags/Arrays/"}]}